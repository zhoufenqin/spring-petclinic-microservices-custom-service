name: AppCAT Java Application Analysis

on:
  workflow_dispatch:
    inputs:
      appcat_version:
        description: "AppCAT version to use"
        required: true
        default: "7.7.0.7"
        type: string
      analysis_targets:
        description: "Analysis targets (comma-separated)"
        required: true
        default: "azure-aks,azure-container-apps,azure-appservice"
        type: string
      issue_url:
        description: "GitHub issue URL to update with report (e.g., https://github.com/owner/repo/issues/8)"
        required: false
        default: "https://github.com/zhoufenqin/spring-petclinic-microservices/issues/8"
        type: string

env:
  APPCAT_VERSION: ${{ github.event.inputs.appcat_version || '7.7.0.7' }}
  ANALYSIS_TARGETS: ${{ github.event.inputs.analysis_targets || 'azure-aks,azure-container-apps,azure-appservice' }}
  APPCAT_DOWNLOAD_URL: ${{ vars.APPCAT_DOWNLOAD_URL || secrets.APPCAT_DOWNLOAD_URL }}

jobs:
  analyze-java-app:
    name: Analyze Java Application with AppCAT
    runs-on: macos-latest
    permissions:
      contents: read
      actions: read
      issues: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download and Setup AppCAT
        run: |
          # Set version and architecture variables
          version="${{ env.APPCAT_VERSION }}"
          arch="arm64"
          name="azure-migrate-appcat-for-java-cli-macos-arm64-$version"
          tar_url="${{ env.APPCAT_DOWNLOAD_URL }}"

          echo "============== Setting up AppCAT =============="

          # Download AppCAT
          echo "> Downloading AppCAT from: $tar_url"
          curl -L -O -J "$tar_url"

          # Extract AppCAT
          echo "> Extracting AppCAT..."
          tar -xzf $name.tar.gz

          # Test AppCAT
          echo "> Testing AppCAT..."
          chmod +x $name/appcat
          ./$name/appcat --help

      - name: Run AppCAT Analysis on Current Repository
        run: |
          version="${{ env.APPCAT_VERSION }}"
          arch="arm64"
          name="azure-migrate-appcat-for-java-cli-macos-arm64-$version"

          echo "============== Analyzing Current Repository =============="
          echo "> Repository: ${{ github.repository }}"
          echo "> Branch: ${{ github.ref_name }}"
          echo "> Commit: ${{ github.sha }}"
          echo "> Targets: ${{ env.ANALYSIS_TARGETS }}"

          # Run AppCAT analysis on the current repository
          ./$name/appcat analyze \
            --input . \
            --target ${{ env.ANALYSIS_TARGETS }} \
            --output ./appcat-report \
            --overwrite \
            --code-snips-number 1 \
            --disable-telemetry

          echo "âœ… Analysis completed successfully!"

      - name: Upload AppCAT Report
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: appcat-analysis-report-${{ github.run_number }}
          path: appcat-report
          retention-days: 30

      - name: Display Report Summary
        if: always()
        run: |
          echo "============== AppCAT Analysis Summary =============="
          echo "Report generated at: appcat-report"
          echo "Download the artifact to view the full report."
          if [ -f appcat-report/report.json ]; then
            echo ""
            echo "Preview of findings:"
            head -n 50 appcat-report/report.json
          fi

      - name: Update GitHub Issue with Report
        if: always()
        uses: actions/github-script@v7
        env:
          ISSUE_URL: ${{ github.event.inputs.issue_url || 'https://github.com/zhoufenqin/spring-petclinic-microservices/issues/8' }}
          ASSESSMENT_SUMMARY_MARKER: '<!--assessment-report-overview-->'
        with:
          github-token: ${{ secrets.PAT_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const path = require('path');
            
            // Parse issue URL to extract owner, repo, and issue number
            const issueUrl = process.env.ISSUE_URL;
            const urlMatch = issueUrl.match(/github\.com\/([^\/]+)\/([^\/]+)\/issues\/(\d+)/);
            
            if (!urlMatch) {
              console.log(`âŒ Invalid issue URL format: ${issueUrl}`);
              console.log('Expected format: https://github.com/owner/repo/issues/123');
              return;
            }
            
            const owner = urlMatch[1];
            const repo = urlMatch[2];
            const issueNumber = parseInt(urlMatch[3]);
            
            console.log(`ðŸ“ Updating issue: ${owner}/${repo}#${issueNumber}`);
            
            const ASSESSMENT_SUMMARY_MARKER = process.env.ASSESSMENT_SUMMARY_MARKER;
            const MAX_COMMENT_LENGTH = 60000 * 4; // GitHub comment max size with buffer
            
            // Helper function to split content into chunks
            function splitMarkdownContent(fullMarkdown, maxLength = MAX_COMMENT_LENGTH) {
              const lines = fullMarkdown.split('\n');
              const chunks = [];
              let currentChunk = [];
              let currentLength = 0;
              
              for (const line of lines) {
                const lineLength = line.length + 1;
                
                if (currentLength + lineLength > maxLength && currentChunk.length > 0) {
                  chunks.push(currentChunk.join('\n'));
                  currentChunk = [];
                  currentLength = 0;
                }
                
                currentChunk.push(line);
                currentLength += lineLength;
              }
              
              if (currentChunk.length > 0) {
                chunks.push(currentChunk.join('\n'));
              }
              
              return chunks.length > 0 ? chunks : [fullMarkdown];
            }
            
            // Helper function to generate summary content from report JSON
            function generateSummaryContent(reportJson) {
              const metadata = reportJson.metadata || {};
              const targetDisplayNames = metadata.targetDisplayNames || [];
              const targetIds = metadata.targetIds || [];
              const rules = reportJson.rules || {};
              
              let summary = `# App Modernization Assessment Summary\n\n`;
              summary += `**Repository:** \`${{ github.repository }}\`\n`;
              summary += `**Branch:** \`${{ github.ref_name }}\`\n`;
              summary += `**Workflow Run:** [#${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})\n`;
              summary += `**Analysis Date:** ${new Date().toISOString()}\n\n`;
              summary += `**Target Azure Services**: ${targetDisplayNames.join(', ')}\n\n`;
              summary += `## Overall Statistics\n\n`;
              
              const azureTargets = ["azure-appservice", "azure-aks", "azure-container-apps"];
              const filteredTargets = targetIds.filter(target => azureTargets.includes(target));
              
              // Group projects by appName
              const projectsByApp = new Map();
              const projectsWithoutAppName = [];
              
              for (const project of reportJson.projects) {
                const appName = project.properties?.appName || '';
                if (!appName) {
                  projectsWithoutAppName.push(project);
                  continue;
                }
                if (!projectsByApp.has(appName)) {
                  projectsByApp.set(appName, []);
                }
                projectsByApp.get(appName).push(project);
              }
              
              summary += `**Total Applications**: ${projectsByApp.size || 1}\n\n`;
              
              // Count severity by app and target
              for (const [appName, projects] of projectsByApp.entries()) {
                const ruleTargets = new Map();
                
                for (const project of projects) {
                  for (const incident of project.incidents || []) {
                    const incidentLabels = incident.labels || [];
                    const hasViolationLabel = incidentLabels.some(label => 
                      typeof label === 'string' && label === 'type=violation'
                    );
                    if (!hasViolationLabel) continue;
                    
                    const ruleId = incident.ruleId;
                    if (!ruleTargets.has(ruleId)) {
                      ruleTargets.set(ruleId, new Map());
                    }
                    
                    const targets = incident.targets || {};
                    for (const [targetId, targetInfo] of Object.entries(targets)) {
                      if (filteredTargets.includes(targetId)) {
                        const rule = rules[ruleId];
                        ruleTargets.get(ruleId).set(targetId, {
                          severity: targetInfo.severity || rule?.severity || 'information',
                          effort: targetInfo.effort || rule?.effort || 0
                        });
                      }
                    }
                  }
                }
                
                const targetSeverityCounts = new Map();
                for (const targetId of filteredTargets) {
                  targetSeverityCounts.set(targetId, { mandatory: 0, potential: 0, optional: 0 });
                }
                
                for (const [ruleId, targets] of ruleTargets.entries()) {
                  for (const [targetId, info] of targets.entries()) {
                    const counts = targetSeverityCounts.get(targetId);
                    if (info.severity === 'mandatory') counts.mandatory++;
                    else if (info.severity === 'potential') counts.potential++;
                    else if (info.severity === 'optional') counts.optional++;
                  }
                }
                
                summary += `**Name: ${appName}**\n`;
                for (let i = 0; i < filteredTargets.length; i++) {
                  const targetId = filteredTargets[i];
                  const displayName = targetDisplayNames[i] || targetId;
                  const counts = targetSeverityCounts.get(targetId);
                  summary += `- ${displayName}: ${counts.mandatory} Mandatory, ${counts.potential} Potential, ${counts.optional} Optional\n`;
                }
                summary += `\n`;
              }
              
              summary += `> **Severity Levels Explained:**\n`;
              summary += `> - **Mandatory**: The issue has to be resolved for the migration to be successful.\n`;
              summary += `> - **Potential**: This issue may be blocking in some situations but not in others. These issues should be reviewed to determine whether a change is required or not.\n`;
              summary += `> - **Optional**: The issue discovered is real issue fixing which could improve the app after migration, however it is not blocking.\n\n`;
              
              // Add Applications Profile section
              summary += `## Applications Profile\n\n`;
              
              for (const [appName, projects] of projectsByApp.entries()) {
                const firstProject = projects[0];
                const properties = firstProject.properties || {};
                
                summary += `### Name: ${appName}\n`;
                summary += `- **JDK Version**: ${properties.jdkVersion || 'N/A'}\n`;
                summary += `- **Frameworks**: ${properties.frameworks?.join(', ') || 'N/A'}\n`;
                summary += `- **Languages**: ${properties.languages?.join(', ') || 'N/A'}\n`;
                summary += `- **Build Tools**: ${properties.tools?.join(', ') || 'N/A'}\n\n`;
                
                const ruleData = new Map();
                
                for (const project of projects) {
                  for (const incident of project.incidents || []) {
                    const incidentLabels = incident.labels || [];
                    const hasViolationLabel = incidentLabels.some(label => 
                      typeof label === 'string' && label === 'type=violation'
                    );
                    if (!hasViolationLabel) continue;
                    
                    const ruleId = incident.ruleId;
                    const rule = rules[ruleId];
                    
                    if (!ruleData.has(ruleId)) {
                      const linksData = rule?.links || [];
                      const links = linksData.map(link => 
                        typeof link === 'string' ? link : link.url || ''
                      ).filter(Boolean);
                      
                      ruleData.set(ruleId, {
                        count: 0,
                        targets: new Map(),
                        links
                      });
                    }
                    
                    const data = ruleData.get(ruleId);
                    data.count++;
                    
                    const targets = incident.targets || {};
                    for (const [targetId, targetInfo] of Object.entries(targets)) {
                      if (filteredTargets.includes(targetId) && !data.targets.has(targetId)) {
                        data.targets.set(targetId, {
                          severity: targetInfo.severity || rule?.severity || 'information',
                          effort: targetInfo.effort || rule?.effort || 0
                        });
                      }
                    }
                  }
                }
                
                summary += `**Key Findings**:\n\n`;
                
                for (const [ruleId, data] of ruleData.entries()) {
                  const rule = rules[ruleId];
                  const title = rule?.title || ruleId;
                  
                  summary += `- <details>\n`;
                  summary += `  <summary><!--ruleid=${ruleId}--><b>${title}</b> (${data.count} location${data.count !== 1 ? 's' : ''})</summary>\n`;
                  summary += `  \n`;
                  
                  for (let i = 0; i < filteredTargets.length; i++) {
                    const targetId = filteredTargets[i];
                    const displayName = targetDisplayNames[i] || targetId;
                    const targetInfo = data.targets.get(targetId);
                    if (targetInfo) {
                      summary += `  - ${displayName}: ${targetInfo.severity}, Effort: ${targetInfo.effort}\n`;
                    }
                  }
                  
                  summary += `  </details>\n`;
                  
                  if (data.links.length > 0) {
                    summary += `  \n`;
                    summary += `  **Links**: ${data.links.join(', ')}\n`;
                  }
                  
                  summary += `\n`;
                }
              }
              
              summary += `## Next Steps\n\n`;
              summary += `For comprehensive migration guidance and best practices, visit:\n`;
              summary += `- [GitHub Copilot App Modernization](https://aka.ms/ghcp-appmod)\n\n`;
              summary += `### ðŸ“¥ Download Full Report\n\n`;
              summary += `Download the complete analysis report from the [workflow artifacts](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}).\n`;
              
              return summary;
            }
            
            // Read and parse report
            let reportJson;
            const reportPath = path.join('./appcat-report', 'report.json');
            
            try {
              if (fs.existsSync(reportPath)) {
                const reportContent = fs.readFileSync(reportPath, 'utf8');
                reportJson = JSON.parse(reportContent);
                console.log(`âœ… Successfully read report.json`);
              } else {
                console.log(`âŒ Report file not found at ${reportPath}`);
                return;
              }
            } catch (error) {
              console.log(`âŒ Failed to read or parse report: ${error.message}`);
              return;
            }
            
            // Generate summary content
            const summaryContent = generateSummaryContent(reportJson);
            
            // Split into chunks if needed
            const chunks = splitMarkdownContent(summaryContent);
            const totalParts = chunks.length;
            
            console.log(`ðŸ“„ Generated ${totalParts} comment part(s)`);
            
            // Get existing comments
            const { data: comments } = await github.rest.issues.listComments({
              owner,
              repo,
              issue_number: issueNumber
            });
            
            const { data: userData } = await github.rest.users.getAuthenticated();
            const userLogin = userData.login;
            
            const existingComments = comments
              .filter(c => c.body?.includes(ASSESSMENT_SUMMARY_MARKER) && c.user?.login === userLogin)
              .sort((a, b) => a.created_at.localeCompare(b.created_at));
            
            // Post/update each chunk
            for (let i = 0; i < totalParts; i++) {
              const pageInfo = totalParts > 1 ? ` (Page ${i + 1}/${totalParts})` : '';
              const body = `${ASSESSMENT_SUMMARY_MARKER}${pageInfo}\n\n${chunks[i]}`;
              
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: issueNumber,
                body
              });
              console.log(`âœ… Created comment part ${i + 1}/${totalParts}`);
            }
            
            console.log(`âœ… Successfully posted ${totalParts} new comment(s) to issue #${issueNumber} in ${owner}/${repo}`);
